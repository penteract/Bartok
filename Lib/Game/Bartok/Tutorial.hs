{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# OPTIONS_GHC -Wno-missing-export-lists #-}
{-# OPTIONS_HADDOCK prune #-}

-- |
-- Module      : Tutorial
-- Description : A walkthrough of how to play Bartok.
module Game.Bartok.Tutorial where

import Control.Lens (makeLenses, (%%~), (%~), (^.))
import Control.Monad (ap)
import Control.Monad.Trans.State (StateT (StateT), evalStateT, runStateT)
import Data.Char (isSpace, toLower)
import Data.List (isPrefixOf, stripPrefix)
import Data.List.NonEmpty (NonEmpty (..))
import Data.Map (Map)
import qualified Data.Map as Map (empty, findWithDefault, fromList, insert) -- (insert,findWithDefault,empty,fromList)
import Data.Maybe (listToMaybe)
import System.Random (StdGen, mkStdGen, split)
import System.Random.Shuffle (shuffle')
import Utils ((/\))

-- $doc
-- Note that this file involves copy-pasting a bunch of definitions so that it generates nice haddock.
-- It may be inaccurate or out of date.

-- * Framework

-- | A Game is essentially a ruleset that defines how an event modifies the
-- gamestate.
type Game = Event -> GameState -> GameState
-- ^
-- For example, in the following game nothing that happens has any effect:
--
--     > useless :: Game
--     > useless event state = state

-- |
-- A game of Bartok, from the server's point of view, consists of
-- events arriving and affecting the gamestate.
--
-- Actions are the most interesting, and always come with a message (which may be the empty string).
data Event
  = -- | A player actually doing something (playing a card or drawing cards)
    Action Name Action String
  | -- | If no player has made an action for 10 seconds, this event will be sent.
    Timeout
  | -- | This is handled by the base game. You probably want to leave it alone.
    PlayerJoin Name (Maybe (Name, Name))
  | -- | A player leaving the game. Again handled by the base game.
    PlayerLeave Name

-- | A game is a composition of rules
-- such as 'r1 (r2 (r3 useless))' .
--
-- For example, the following rule will stop players being penalized for timeouts.
--
-- > rLongTurns :: Rule
-- > rLongTurns oldgame Timeout gamestate = gamestate
-- > rLongTurns oldgame event gamestate = oldgame event gamestate
--
-- You usually want to call @oldgame event gamestate@ at some point
-- so that rules which have been implemented before yours get a chance to do something.
type Rule = Game -> Game

-- $doc
-- The rest of this tutorial is unfinished, and 'Game.Bartok.DataTypes' is a better reference.
-- See 'Game.Bartok.TLib' for a framework to make rules
-- and the source code of 'Game.Bartok.TSample' for sample rules using it.

-- ** Gamestate
{-
 One of the easiest things to do is award penalties 'Game.Bartok.TLib.penalty'
-}

-- | Transformations of gamestate.
type Step = GameState -> GameState

data Suit = Clubs | Diamonds | Hearts | Spades deriving (Show, Eq, Enum, Bounded, Ord)

data Rank = Ace | Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten | Jack | Knight | Queen | King deriving (Show, Eq, Bounded, Ord)

-- | A single playing card
type Card = (Rank, Suit)

-- | An ordered collection of cards forming a player's hand
type Hand = [Card]

-- | Names of players.
type Name = String

-- | At any point, a player can attempt to take one of these actions
data Action
  = -- | Draw some number of cards
    Draw Int
  | -- | Play a card
    Play Card
  deriving (Show, Eq)

-- \ Identifiers for variables
type VarName = String

--TODO: make the documentation true (messages and lastMoveLegal)

-- | The state of a game in play
data GameState = GS
  { -- | The players curretly in the game. The player whose turn it is should be at head of list
    -- and usually this advances forward by 1 each turn.
    _players :: [Name],
    -- | Stores the contents of each player's hand
    _hands :: Map Name Hand,
    -- | The deck from which cards are drawn
    _deck :: [Card],
    -- | The cards that have been played - shuffled back into the deck when necessary.
    _pile :: NonEmpty Card,
    -- | The messages that .  Contains only those generated by the most recent event.
    _messages :: [String],
    -- | Indicates if the last move was successful.
    -- When a new event happens, this is False until baseAct is called.
    _lastMoveLegal :: Bool,
    -- | A seeded random number generator
    _randg :: StdGen,
    -- | @Nothing@ until a player p wins at which point it becomes @Just p@
    _winner :: Maybe Name,
    -- | A store of named variables that rules may use to keep track of state between events.
    _varMap :: Map VarName Int
  }
  deriving (Show)

-- I'll try not to expose casual readers to lenses.
-- They are fun and powerful, but arguably turn Haskell into a different language.
makeLenses ''GameState

-- ** View Rules

-- | A card as viewed - the type of cards sent to the client
data CardView = CardFace Card | CardBack deriving (Show)

-- | The structure describing data seen by players
data GameView = GV
  { -- | The players and the information a particular player will have about each hand.
    -- By default, this is a 'CardFace's for the viewing player and a number of 'CardBack's for others.
    _handsV :: [(Name, [CardView])],
    -- | What should be seen of the pile. By default, only the top card is visible.
    _pileV :: [CardView],
    -- | What should be seen of the pile. By default, none are visible.
    _deckV :: [CardView],
    -- | The messages a player can see. By default, this is all messages that have been sent
    _messagesV :: [String]
  }
  deriving (Show)

makeLenses ''GameView

-- handsV :: Lens' GameView [(Name,[CardView])]
-- handsV f gv@GV{_handsV = h} = (\h' -> gv{_handsV = h'}) <$> f h
-- deckV :: Lens' GameView  [CardView]
-- deckV f gv@GV{_deckV = d} = (\d' -> gv{_deckV = d'}) <$> f d
-- pileV :: Lens' GameView  [CardView]
-- pileV f gv@GV{_pileV = p} = (\p' -> gv{_pileV = p'}) <$> f p
-- messagesV :: Lens' GameView  [String]
-- messagesV f gv@GV{_messagesV = m} = (\m' -> gv{_messagesV = m'}) <$> f m

-- | Functions to tell a player what they should see
type Viewer = Name -> GameState -> GameView

-- | Rules that modify what players see without affecting the game state
type ViewRule = Viewer -> Viewer

-- | Complex rules
type Rule' = (Rule, ViewRule)

-- Enum instances

instance Enum Rank where
  toEnum i = case i of
    1 -> Ace
    2 -> Two
    3 -> Three
    4 -> Four
    5 -> Five
    6 -> Six
    7 -> Seven
    8 -> Eight
    9 -> Nine
    10 -> Ten
    11 -> Jack
    12 -> Knight
    13 -> Queen
    14 -> King
    _ -> error "Enum Rank instance only covers 1..14"
  fromEnum r = case r of
    Ace -> 1
    Two -> 2
    Three -> 3
    Four -> 4
    Five -> 5
    Six -> 6
    Seven -> 7
    Eight -> 8
    Nine -> 9
    Ten -> 10
    Jack -> 11
    Knight -> 12
    Queen -> 13
    King -> 14
  enumFrom n = map toEnum [fromEnum n .. fromEnum (maxBound :: Rank)]

fullDeck :: [Card]
fullDeck = [(r, s) | r <- [minBound ..], s <- [minBound ..]]

next :: (Enum a, Bounded a, Eq a) => a -> a
next a = if a == maxBound then minBound else succ a

prev :: (Enum a, Bounded a, Eq a) => a -> a
prev a = if a == minBound then maxBound else pred a

suitChar :: Suit -> Char
suitChar s = case s of
  Clubs -> 'C'
  Diamonds -> 'D'
  Hearts -> 'H'
  Spades -> 'S'

-- | Get the suit of a card.
suit :: Card -> Suit
suit = snd

-- | Get the rank of a card.
rank :: Card -> Rank
rank = fst

-- | One character corresponding to the rank (A1..9TJCQK)
rankChar :: Rank -> Char
rankChar r = (['A'] ++ [head $ show i | i <- [2 .. 9] :: [Int]] ++ ['T', 'J', 'C', 'Q', 'K']) !! (fromEnum r - 1) -- UNSAFE

-- | Get the unicode playing card character corresponding to some card
uniCard :: Card -> Char
uniCard (r, s) = toEnum (0x1F0A0 + (fromEnum (maxBound :: Suit) + fromEnum (minBound :: Suit) - fromEnum s) * 16 + fromEnum r)

--reading cards

type Parser = StateT String Maybe

-- | Given 2 parsers, tries the first, if it fails, try the second
(<|>) :: Parser a -> Parser a -> Parser a
a <|> b =
  StateT
    ( \s -> case runStateT a s of
        Just (x, s') -> Just (x, s')
        Nothing -> runStateT b s --note that state is saved - Parsec does not do this for efficiency
    )

runParser :: Parser a -> String -> Maybe a
runParser = evalStateT

parseRank :: Parser Rank
parseRank =
  StateT
    ( \s ->
        fmap (\(r, c) -> (r, drop (length c) s)) $ listToMaybe $
          filter
            (\(_, c) -> isPrefixOf (map toLower c) (map toLower s))
            (map (\x -> (x, show x)) (enumFrom minBound) ++ map (\x -> (x, ((: []) . rankChar) x)) (enumFrom minBound))
    )

parseSuit :: Parser Suit
parseSuit =
  StateT
    ( \s ->
        fmap (\(r, c) -> (r, drop (length c) s)) $ listToMaybe $
          filter
            (\(_, c) -> isPrefixOf (map toLower c) (map toLower s))
            (map (\x -> (x, show x)) (enumFrom minBound) ++ map (\x -> (x, ((: []) . suitChar) x)) (enumFrom minBound))
    )

ignore :: String -> Parser ()
ignore s =
  StateT
    ( \s' ->
        let s'' = dropWhile isSpace s'
         in let s''' = stripPrefix s s''
             in fmap ((,) () . dropWhile isSpace) s'''
    )

parseCard :: Parser Card
parseCard = do
  r <- parseRank
  ignore "of" -- and possibly spaces either side
  s <- parseSuit
  return (r, s)

-- | Get the playeer if an event
eventPlayer :: Event -> Maybe Name
eventPlayer (Action p _ _) = Just p
eventPlayer (PlayerJoin p _) = Just p
eventPlayer (PlayerLeave p) = Just p
eventPlayer Timeout = Nothing

-- | variable processing
readVar :: VarName -> GameState -> Int
readVar s gs = Map.findWithDefault 0 s (gs ^. varMap)

setVar :: VarName -> Int -> Step
setVar s i = varMap %~ Map.insert s i

modifyVar :: VarName -> (Int -> Int) -> Step
modifyVar s f gs = setVar s (f $ readVar s gs) gs

-- | Shuffle the deck (does not touch the pile or hands) using the random seed contained in GameState.
shuffleDeck :: Step
shuffleDeck = uncurry ((deck %~) . flip (ap shuffle' length)) . (randg %%~ split)

-- | Set the pile to be just the top card of the deck
popToPile :: Step
popToPile = (pile /\ deck) %~ \case
  (_, y : ys) -> (y :| [], ys)
  x -> x -- make an error?

-- | Construct a new game from a list of player names.
newGame :: [String] -> GameState
newGame pls =
  popToPile . shuffleDeck $
    GS
      { _deck = fullDeck,
        _pile = undefined,
        _messages = [],
        _lastMoveLegal = True,
        _randg = mkStdGen 0,
        _varMap = Map.empty,
        _players = pls, --[("Angus",[]),("Toby",[]),("Anne",[])]
        -- , _seats = pls
        _hands = Map.fromList $ map (flip (,) []) (pls),
        --, _prevGS = Nothing
        _winner = Nothing
      }
